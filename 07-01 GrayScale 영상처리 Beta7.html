<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script> //전역 변수부
        //전역 변수부 
        var inCanvas,inCtx,inPaper; // 입력 캔버스 관련
        var outCanvas,outCtx,outPaper; // 입력 캔버스 관련
        var inImage, outImage; //이미지의 배열
        var inH, inW, ouH, ouW;  //이미지의 크기 
        var inFile; //입력 RAW 파일
    </script>
    <script> //공통 함수부
         //초기화 함수
         function init(){
            inCanvas = document.getElementById('inCanvas'); //도화지에 접근
            inCtx = inCanvas.getContext('2d'); //물감 , 붓이 들은 통
            outCanvas = document.getElementById('outCanvas'); //도화지에 접근
            outCtx = outCanvas.getContext('2d'); //물감 , 붓이 들은 통
        }
        //공통 함수부
        function loadImage(){
            inFile = document.getElementById('inFile').files[0]; //선택한 파일
            aaaFile = document.getElementById('inFile').files[0]; //선택한 파일

            // * 중요 * 이미지의 크기를 파악! 
            inH = inW = Math.sqrt(inFile.size); // 512,512
            //입력 이미지의 메모리 할당 
            inImage; //2차원 배열 (이미지 --> 2차원 배열)
            inImage = new Array(inH);
            for(var i=0; i<inH; i++){
                inImage[i] = new Array(inW);
            }
            // 캔버스 크기를 결정 
            inCanvas.height = inH;
            inCanvas.width = inW;
            //파일 --> 메모리로 로딩
            var reader = new FileReader();
            reader.readAsBinaryString(inFile);
            reader.onload = function() {
                var blob = reader.result; // 파일을 덩어리 (Blob)으로 가져옴. 
                // 덩어리 (Blob)에서 한점한점 뽑아서 ,, 우리꺼 배열에 넣기!
                for(var i=0; i<inH; i++){
                    for(var k=0; k<inW; k++){
                        var sPixel = (i*inH + k);//시작위치
                        var ePixel = (i*inH + k) + 1;//끝위치
                        inImage[i][k] = blob.slice(sPixel,ePixel);

                    }
                }
                // ** 입력 메모리의 내용을 화면에 출력하기 . 
                
                inPaper = inCtx.createImageData(inH,inW); //캔버스에 종이 붙이기 (크기는 캔버스 동일)
                for(var i=0; i<inH; i++){
                    for(var k=0; k<inW; k++){
                        var pix = inImage[i][k].charCodeAt(0); // 이상한 문자(꽯)를 숫자(231)로.
                        //RGB값이 다르면 color고 , RGB값이 같으면 Gray Scale 임 
                        inPaper.data[(i*inH + k) * 4 + 0] = pix; //RED,4바이트로 한개의 컬러를 표현  
                        inPaper.data[(i*inH + k) * 4 + 1] = pix; //GREEN,종이의 한 점당 4바이트  
                        inPaper.data[(i*inH + k) * 4 + 2] = pix;  //Blue 
                        inPaper.data[(i*inH + k) * 4 + 3] = 255;  //Alpha , 투명 제로 [불투명]

                    }
                }
                inCtx.putImageData(inPaper,0,0); //(0,0) 좌표에 붙여라 . 
            }
        }
        function displayImage(){
            // ** 출력 메모리의 내용을 화면에 출력하기 . 
                
            outPaper = outCtx.createImageData(outH,outW); //캔버스에 종이 붙이기 (크기는 캔버스 동일)
            for(var i=0; i<outH; i++){
                for(var k=0; k<outW; k++){
                    var pix = outImage[i][k].charCodeAt(0); // 이상한 문자(꽯)를 숫자(231)로.
                    //RGB값이 다르면 color고 , RGB값이 같으면 Gray Scale 임 
                    outPaper.data[(i*outH + k) * 4 + 0] = pix; //RED,4바이트로 한개의 컬러를 표현  
                    outPaper.data[(i*outH + k) * 4 + 1] = pix; //GREEN,종이의 한 점당 4바이트  
                    outPaper.data[(i*outH + k) * 4 + 2] = pix;  //Blue 
                    outPaper.data[(i*outH + k) * 4 + 3] = 255;  //Alpha

                }
            }
            outCtx.putImageData(outPaper,0,0); //(0,0) 좌표에 붙여라 . 
        }
        
        function saveImage(){

        }
        
    </script>
    <script> //영상처리 함수부
        function selectAlgorithm(selectNum){

            switch (parseInt(selectNum.value)){ // 101,102....
                case 101: //동일 영상 
                    // alert(selectNum.value);
                    equalImage();
                    break;
                case 102: //밝게 어둡게
                    addImage();
                    break;
                case 103: //흑백(127기준)
                    numbkImage();
                    break;
                case 104: //흑백(입력값 기준)
                    inputbkImage();
                    break;
                case 105 : //흑백(평균값 기준)
                    blackImage();
                    break;
                case 106 : //흑백(중앙값 기준)
                    centbkImage();
                    break;
                case 107 : //파라볼라(cap)
                    paraCap();
                    break;
                case 108 : //감마 보정 프로그램
                    gammaImg();
                    break;
                case 201 : //축소하기
                    zoomOut();
                    break;
                case 202 : //확대하기
                    zoomIn();
                    break;
                case 203 : //확대하기 (백워딩)
                    zoomIn2();
                    break;
                case 204 : //양선형 보간법
                    biLinear();
                    break;
                case 301 : //히스토그램 스트레칭
                    histoStretch();
                    break;
                case 302 : //엔드인 탐색
                    endInSearch();
                    break;
                case 303 : //평활화
                    histoEqual();
                    break;
                case 401 : //반전하기
                    revImage();
                    break;
                case 402 : //미러링하기
                    mirImage();
                    break;
                case 403 : //90도 회전하기
                    rotateNine();
                    break;
                case 404 : //각도회전(값입력)
                    rotateNum();
                    break;
                case 501 : //화소처리(AND 프로그램)
                    andImage();
                    break;
                case 502 : //화소처리(OR 프로그램)
                    orImage();
                    break;
                case 503 : //화소처리(XOR 프로그램)
                    xorImage();
                    break;
                case 504 : //Alpha 값 주기
                    alpha();
                    break;
                case 505 : //범위 강조 변환
                    stressImage();
                    break;
                case 601 : //엠보싱
                    embossing();
                    break;
                case 602 : //블러링
                    blurring();
                    break;
                case 603 : //경계선1
                    edge1();
                    break;
                case 604 : //유사 연산자
                    homogenOperator();
                    break;
                case 605 : //차 연산자
                    diffOperator();
                    break;
                case 606 : //LoG
                    loGImage();
                    break;
                case 607 : //DoG
                    doGImage();
                    break;
                case 608 : //블러링(진하기)
                    blurrOperator();
                    break;
                case 609 : //이동과 차분 처리
                    diffOpHor();
                    break;
                case 610 : //샤프닝
                    sharpening();
                    break;
                case 611 : //가우시안 필터
                    gaussianFilter();
                    break;
                case 612 : //고주파 필터 샤프닝
                    hpfSharp();
                    break;
                case 613 : //저주파 필터 샤프닝
                    lpfSharp();
                    break;
                
            }
        }

        // 영상처리 함수부
        function equalImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘 . 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    outImage[i][k] = inImage[i][k];
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
        }
        function addImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            var value = parseInt(prompt("숫자를 입력 :", "100"));
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자 
                    var pixel = inImage[i][k].charCodeAt(0);
                    // ** 진짜 핵심 알고리즘
                    if (pixel + value > 255)
                        pixel = 255;
                    else if(pixel + value <0){
                        pixel = 0;
                    }
                    else
                        pixel += value;
                    //숫자 --> 문자 
                    outImage[i][k] = String.fromCharCode(pixel);
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
        }

        function seqImage(){
             //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            if(outImage == null){
                outImage = new Array(outH);
                for(var i=0; i<outH; i++){
                    outImage[i] = new Array(outW);
                }
                for(var i=0;i<outH;i++){
                    for(var k=0;k<outW;k++){
                        outImage[i][k] = inImage[i][k];
                    }
                }
            }
            var value = parseInt(prompt("숫자를 입력 :", "100"));
            //영상처리 1 : 사진을 밝게 처리하자 . 
            for(var i=0; i<outH;i++){
                for(var k=0; k<outW; k++){
                    //문자 --> 숫자 
                    var pixel = outImage[i][k].charCodeAt(0);
                    // ** 진짜 핵심 알고리즘
                    if (pixel + value > 255)
                        pixel = 255;
                    else
                        pixel += value;
                    //숫자 --> 문자 
                    outImage[i][k] = String.fromCharCode(pixel);
                }
            }
            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function numbkImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존 
            outH = inH; 
            outW = inW; 
            //캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage = new Array(outH); //2차원 배열 (이미지 --> 2차원 배열)
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outH);
            }
            //영상처리 : 흑백처리 [127 기준]

            for(var i=0; i<inH; i++){
                for(var k=0; k<inW; k++){
                    var pixel = inImage[i][k].charCodeAt(0);
                    if (pixel <= 127) {
                        pixel = 0;
                    }
                    else{
                        pixel = inW;
                    }
                    outImage[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }

        function inputbkImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존 
            outH = inH; 
            outW = inW; 
            //캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage = new Array(outH); //2차원 배열 (이미지 --> 2차원 배열)
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outH);
            }
            //영상처리 : 흑백처리 [입력값 기준]
            var value = parseInt(prompt("숫자를 입력 : " , "100"));
            for(var i=0; i<inH; i++){
                for(var k=0; k<inW; k++){
                    var pixel = inImage[i][k].charCodeAt(0);
                    if (pixel < value) {
                        pixel = 0;
                    }
                    else if(pixel > value){
                        pixel = 255;
                    }
                    else{
                        pixel = inW;
                    }
                    outImage[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }

        

        function blackImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존 
            outH = inH; 
            outW = inW; 
            //캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage = new Array(outH); //2차원 배열 (이미지 --> 2차원 배열)
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outH);
            }
            //영상처리 : 흑백처리 [평균값 기준]
            var sum = 0;
            var avg = 0;

            for(var i=0; i<inH; i++){
                for(var k=0;k<inW; k++){
                    var pixel = inImage[i][k].charCodeAt(0);
                    sum += pixel;
                }
            }
            // console.log(sum);

            avg = Math.floor(sum/(outH*outW));

            for(var i=0; i<inH; i++){
                for(var k=0; k<inW; k++){
                    var pixel = inImage[i][k].charCodeAt(0);
                    if (pixel < avg) {
                        pixel = 0;
                    }
                    else if(pixel > avg){
                        pixel = 255;
                    }
                    else{
                        pixel = inW;
                    }
                    outImage[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }

        function centbkImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존 
            outH = inH; 
            outW = inW; 
            //캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            
            outImage = new Array(outH); //2차원 배열 (이미지 --> 2차원 배열)
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outH);
            }
            //영상처리 : 흑백처리 [중앙값 기준]
            var ni =0; 
            var narray = new Array();
            for(var i = 0; i < inH; i++){
                for(var k=0; k<inW; k++){
                    //문자 -> 숫자
                    var pixel = inImage[i][k].charCodeAt(0);
                    narray[ni] = pixel;
                    ni++;
                    //숫자 -> 문자
                    inImage[i][k] = String.fromCharCode(pixel);
                }
            }
            oneArry = narray.sort(function(a,b){
                if(a > b)
                    return 1;
                if(a === b)
                    return 0;
                if(a < b)
                    return -1;
            });

            var midVal = oneArry[(Math.floor(oneArry.length / 2))];
            
            for(var i=0; i<inH; i++){
                for(var k=0; k<inW; k++){
                    var pixel = inImage[i][k].charCodeAt(0);
                    if (pixel < midVal) {
                        pixel = 0;
                    }
                    else if(pixel > midVal){
                        pixel = 255;
                    }
                    else{
                        pixel = inW;
                    }
                    outImage[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }

        function paraCap(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘 . 
            // LUT(LookUP Table ) 기법 --> 미리 복잡한 수식을 계산해 놓고 , 가져다 쓰기
            var LUT = new Array(256);
            for(var i=0;i<256;i++){
                var outVal = 255.0 - 255.0 * Math.pow( (i / 127.0 -1) , 2.0);
                    if(outVal > 255.0)
                        outVal = 255.0;
                    
                    if (outVal < 0.0) 
                        outVal = 0.0;
                    LUT[i] = parseInt(outVal);
            }


            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자 
                    var inVal = inImage[i][k].charCodeAt(0);
                    var outVal = LUT[inVal];
                    
                    //숫자 --> 문자
                    outImage[i][k] = String.fromCharCode(outVal);
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
        }

        function gammaImg(){
            var gamaVal = Number(prompt("숫자 입력 :" , "0.8"));
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘 . 
            // LUT(LookUP Table ) 기법 --> 미리 복잡한 수식을 계산해 놓고 , 가져다 쓰기
            var LUT = new Array(256);
            for(var i=0; i<inH; i++){
                var outVal = Math.pow(i, 1/gamaVal);
                //감마 값 계산
                if(outVal < 0.0)
                    outVal = 0;
                else if(outVal > 255)
                    outVal = 255;
                else
                    LUT[i] = Number(outVal);
            }

            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자 
                    var inVal = inImage[i][k].charCodeAt(0);
                    var outVal = LUT[inVal];
                    
                    //숫자 --> 문자
                    outImage[i][k] = String.fromCharCode(outVal);
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
            
        }


        function zoomOut(){
            var scale = parseInt(prompt("축소 배율 :", "2"));
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = parseInt(inH/scale);
            outW = parseInt(inW/scale);
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
           
            //영상처리 1 : 사진을 밝게 처리하자 . 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    // ** 진짜 핵심 알고리즘
                    outImage[parseInt(i/scale)][parseInt(k/scale)] = inImage[i][k];
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
        }

        function zoomIn(){
            var scale = parseInt(prompt("확대 배율 :", "2"));
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = parseInt(inH*scale);
            outW = parseInt(inW*scale);
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
           
            //출력 이미지를 초기화 시키기 
            for(var i=0; i<outH;i++){
                for(var k=0; k<outW; k++){
                    outImage[i][k] = String.fromCharCode(0);
                }
            }

            //영상처리 1 : 사진을 밝게 처리하자 . 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    // ** 진짜 핵심 알고리즘
                    outImage[parseInt(i*scale)][parseInt(k*scale)] = inImage[i][k];
                }
            }
             // ** 출력 메모리의 내용을 화면에 출력하기 . 
                
            displayImage();
        }

        function zoomIn2(){
            var scale = parseInt(prompt("확대 배율 :", "2"));
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = parseInt(inH*scale);
            outW = parseInt(inW*scale);
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
           
            //출력 이미지를 초기화 시키기 
            for(var i=0; i<outH;i++){
                for(var k=0; k<outW; k++){
                    outImage[i][k] = String.fromCharCode(0);
                }
            }

            //영상처리 1 : 사진을 밝게 처리하자 . 
            for(var i=0; i<outH;i++){
                for(var k=0; k<outH; k++){
                    // ** 진짜 핵심 알고리즘
                    outImage[i][k] = inImage[parseInt(i/scale)][parseInt(k/scale)];
                }
            }
             // ** 출력 메모리의 내용을 화면에 출력하기 . 
                
            displayImage();
        }

        function biLinear() {
            var zoomRate = parseInt(prompt("확대 배율 :", "2"));
            var largeH, largeW, smallH, smallW;
            var ih, iw, point;
            var c1, c2, c3, c4;

            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = parseInt(inH * zoomRate);
            outW = parseInt(inW * zoomRate);
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++) {
                outImage[i] = new Array(outW);
            }
            //출력 이미지를 초기화 시키기
            for (var i = 0; i < outH; i++) {
                for (var k = 0; k < outH; k++) {
                    outImage[i][k] = String.fromCharCode(0);
                }
            }
            //양선형 보간법
            for (var i = 0; i < outH; i++) {
                for (var k = 0; k < outH; k++) {
                    // ** 진짜 핵심 알고리즘
                    largeH = i / zoomRate;
                    largeW = k / zoomRate;

                    ih = parseInt(largeH);
                    iw = parseInt(largeW);
                    //    console.log(iw);

                    smallH = largeH - ih;
                    smallW = largeW - iw;

                    if (ih < 0 || ih >= (inH - 1) || iw < 0 || iw >= (inW - 1)) { //point = i * outW + k;
                        outImage[i][k] = 255;
                    } else {
                        c1 = inImage[ih][iw].charCodeAt(0);
                        c2 = inImage[ih][iw + 1].charCodeAt(0);
                        c3 = inImage[ih + 1][iw + 1].charCodeAt(0);
                        c4 = inImage[ih + 1][iw].charCodeAt(0);
                        // console.log(c2);

                        var newValue = (c1 * (1 - smallH) * (1 - smallW) +
                            c2 * smallW * (1 - smallH) + c3 * smallW * smallH + c4 * (1 - smallW) * smallH);
                        // point = i * outW + k;
                        outImage[i][k] = newValue;

                    }
                }
            }
            // ** 출력 메모리의 내용을 화면에 출력하기 . 
            outPaper = outCtx.createImageData(outH, outW); //캔버스에 종이 붙이기 (크기는 캔버스 동일)
            for (var i = 0; i < outH; i++) {
                for (var k = 0; k < outW; k++) {
                    var pix = outImage[i][k]; // 이상한 문자(꽯)를 숫자(231)로.
                    //RGB값이 다르면 color고 , RGB값이 같으면 Gray Scale 임 
                    outPaper.data[(i * outH + k) * 4 + 0] = pix; //RED,4바이트로 한개의 컬러를 표현  
                    outPaper.data[(i * outH + k) * 4 + 1] = pix; //GREEN,종이의 한 점당 4바이트  
                    outPaper.data[(i * outH + k) * 4 + 2] = pix; //Blue 
                    outPaper.data[(i * outH + k) * 4 + 3] = 255; //Alpha

                }
            }
            outCtx.putImageData(outPaper, 0, 0); //(0,0) 좌표에 붙여라 . 
        
        }

        function histoStretch(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘
            // out = (in - low) / (high - low) * 255
            high = low = inImage[0][0].charCodeAt(0);
            // 최대 , 최소 찾기 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var pixel = inImage[i][k].charCodeAt(0);
                    if(high < pixel){
                        high = pixel;
                    }
                    if(low > pixel){
                        low = pixel;
                    }
                }
            }

            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자
                    var inVal = inImage[i][k].charCodeAt(0);
                    //알고리즘
                    outVal = (inVal - low) / (high - low) * 255.0;
                    outVal = parseInt(outVal);
                    //숫자 --> 문자 
                    outImage[i][k] = String.fromCharCode(outVal);
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
        }

        function endInSearch(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘
            // out = (in - low) / (high - low) * 255
            high = low = inImage[0][0].charCodeAt(0);


            // 최대 , 최소 찾기 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var pixel = inImage[i][k].charCodeAt(0);
                    if(high < pixel){
                        high = pixel;
                    }
                    if(low > pixel){
                        low = pixel;
                    }
                }
            }
            high -= 50;
            low += 50;

            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자
                    var inVal = inImage[i][k].charCodeAt(0);
                    //알고리즘
                    outVal = (inVal - low) / (high - low) * 255.0;
                    if(outVal > 255.0){
                        outVal = 255.0;
                    }
                    if(outVal < 0.0){
                        outVal = 0.0;
                    }
                    outVal = parseInt(outVal);

                    //숫자 --> 문자 
                    outImage[i][k] = String.fromCharCode(outVal);
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
        }

        function histoEqual(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존 
            outH = inH; 
            outW = inW;
            //캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당
            
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘 
            //1단계 : 히스토그램 생성 
            histo = new Array(256);
            for(var i=0; i<256; i++){ //초기화
                histo[i] = 0;
            }
            for(var i=0; i<inH; i++){
                for(var k=0; k<inW; k++){
                    var value = inImage[i][k].charCodeAt(0);
                    histo[value] ++;
                }
            }
            //2단계 : 누적 히스토그램 생성
            sumHisto = new Array(256);
            for(var i=0; i<256; i++){
                sumHisto[i]=0;
            }
            sumValue =0;
            for(var i=0; i<256; i++){
                sumValue += histo[i];
                sumHisto[i] = sumValue;
            }
            //3단계 : 정규화된 누적 히스토그램
            // n = sumHisto * ( 1/총픽셀수 ) * 화소최대밝기
            normalHisto = new Array(256);
            for(var i=0; i<256; i++){ //초기화 모두 0
                normalHisto[i]=0;
            }
            for(var i=0; i<256; i++){ 
                normalHisto[i] = sumHisto[i] * ( 1 / (inH*inW) ) * 255;
            }
            //정규화 히스토그램을 적용시키기
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자
                    var inVal = inImage[i][k].charCodeAt(0);
                    //알고리즘
                    outVal = normalHisto[inVal];
                    if(outVal > 255.0){
                        outVal = 255.0;
                    }
                    if(outVal < 0.0){
                        outVal = 0.0;
                    }
                    outVal = parseInt(outVal);

                    //숫자 --> 문자 
                    outImage[i][k] = String.fromCharCode(outVal);
                }
            }
            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();

        }


        function revImage(){
            // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존 
            outH = inH;
            outW = inW; 
            //캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage = new Array(outH); //2차원 배열 (이미지 --> 2차원 배열)
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outH);
            }
            //영상처리 : 반전하기 
            for(var i=0; i<inH; i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자 
                    var pixel = inImage[i][k].charCodeAt(0);
                    pixel = Math.abs(255-pixel);
                    //숫자 --> 문자 
                    outImage[i][k] = String.fromCharCode(pixel);
                }
            }
            //**입력 메모리의 내용을 화면에 출력하기 
            displayImage();
        }

        function mirImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존 
            outH = inH; 
            outW = inW;
            //캔버스 크기를 결정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage = new Array(outH); //2차원 배열 (이미지 --> 2차원 배열)
            for(var i=0; i< outH; i++){
                outImage[i] = new Array(outH);
            }
            //영상처리 : 미러링하기 
            inImage.reverse();//상하
            for(var i=0; i<inH; i++){
                inImage[i].reverse(); //좌우
                for(var k=0; k<inW; k++){
                    outImage[i][k] = inImage[i][k];
                }
            }
            displayImage();
        }

        function andImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            var value = parseInt(prompt("숫자를 입력 : ","128"));

            //영상처리 : AND 영상 처리 [화소 점]. 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    // ** 진짜 핵심 알고리즘
                    var pixel = inImage[i][k].charCodeAt(0);
                    if ((pixel & value) >= 255) {
                        pixel = 255;
                    }
                    else if((pixel & value)< 0){
                        pixel = 0;
                    }
                    else{
                        pixel = (pixel & value);
                    }
                    // console.log(inImage[i][k] && value);
                    outImage[i][k] = String.fromCharCode(pixel);
                 
                }
            }
             // ** 출력 메모리의 내용을 화면에 출력하기 . 
                
            displayImage();
        }

        function orImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            var value = parseInt(prompt("숫자를 입력 : ","128"));

            //영상처리 : AND 영상 처리 [화소 점]. 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    // ** 진짜 핵심 알고리즘
                    var pixel = inImage[i][k].charCodeAt(0);
                    if ((pixel | value) >= 255) {
                        pixel = 255;
                    }
                    else if((pixel | value)< 0){
                        pixel = 0;
                    }
                    else{
                        pixel = (pixel | value);
                    }
                    // console.log(inImage[i][k] && value);
                    outImage[i][k] = String.fromCharCode(pixel);
                 
                }
            }
             // ** 출력 메모리의 내용을 화면에 출력하기 . 
                
            displayImage();
        }

        function xorImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            var value = parseInt(prompt("숫자를 입력 : ","128"));

            //영상처리 : AND 영상 처리 [화소 점]. 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    // ** 진짜 핵심 알고리즘
                    var pixel = inImage[i][k].charCodeAt(0);
                    if ((pixel ^ value) >= 255) {
                        pixel = 255;
                    }
                    else if((pixel ^ value)< 0){
                        pixel = 0;
                    }
                    else{
                        pixel = (pixel ^ value);
                    }
                    // console.log(inImage[i][k] && value);
                    outImage[i][k] = String.fromCharCode(pixel);
                 
                }
            }
             // ** 출력 메모리의 내용을 화면에 출력하기 . 
                
            displayImage();
        }
        
        function alpha(){
            var value = parseInt(prompt("알파값 :", "100"));
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘 . 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    outImage[i][k] = inImage[i][k];
                }
            }
                
            outPaper = outCtx.createImageData(outH,outW); //캔버스에 종이 붙이기 (크기는 캔버스 동일)
            for(var i=0; i<outH; i++){
                for(var k=0; k<outW; k++){
                    var pix = outImage[i][k].charCodeAt(0); // 이상한 문자(꽯)를 숫자(231)로.
                    //RGB값이 다르면 color고 , RGB값이 같으면 Gray Scale 임 
                    outPaper.data[(i*outH + k) * 4 + 0] = pix; //RED,4바이트로 한개의 컬러를 표현  
                    outPaper.data[(i*outH + k) * 4 + 1] = pix; //GREEN,종이의 한 점당 4바이트  
                    outPaper.data[(i*outH + k) * 4 + 2] = pix;  //Blue 
                    outPaper.data[(i*outH + k) * 4 + 3] = value;  //Alpha

                }
            }
            outCtx.putImageData(outPaper,0,0); //(0,0) 좌표에 붙여라 . 
        }

        function stressImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            //영상처리 알고리즘
            var startPoint = parseInt(prompt("시작 값 :", 100 ));
            var endPoint = parseInt(prompt("끝 값 : ", 150));


            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    //문자 --> 숫자
                    var inVal = inImage[i][k].charCodeAt(0);
                    //알고리즘
                    if(inVal >= startPoint && inVal <= endPoint)
                        inVal = 255;
                    else
                        outImage[i][k] = inVal;

                    //숫자 --> 문자 
                    outImage[i][k] = String.fromCharCode(inVal);
                }
            }
             // ** 입력 메모리의 내용을 화면에 출력하기 . 
             displayImage();
        }

        function embossing(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [ [ -1, 0, 0],
                        [ 0, 0, 0],
                        [ 0, 0, 1] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    tmpOutImage[i][k] += 127;
                }
            }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function blurring(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [ [ 1/9.0, 1/9.0, 1/9.0],
                        [ 1/9.0, 1/9.0, 1/9.0],
                        [ 1/9.0, 1/9.0, 1/9.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function edge1(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [ [ -1/9.0, -1/9.0, -1/9.0],
                        [ -1/9.0, 8/9.0, -1/9.0],
                        [ -1/9.0, -1/9.0, -1/9.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    tmpOutImage[i][k] += 127;
                }
            }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function homogenOperator(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            // var mask = [ [ -1/9.0, -1/9.0, -1/9.0],
            //             [ -1/9.0, 8/9.0, -1/9.0],
            //             [ -1/9.0, -1/9.0, -1/9.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0; //블록이 이동할 때마다 최대값 초기화
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            if(Math.abs(tmpInImage[i+1][k+1] - tmpInImage[i+n][k+m]) >= S){
                                //블록의 가운데 값 - 블록의 주변 픽셀 값이 절대 값 
                                // 중에서 최대값을 찾는다 . 
                            }
                            S = Math.abs(tmpInImage[i+1][k+1].charCodeAt(0) - tmpInImage[i+n][k+m].charCodeAt(0));
                        }
                    }
                    tmpOutImage[i][k] = S; //찾은 최대값을 출력 값으로 지정
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function diffOperator(){
            // 중요! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정
            outCanvas.height = outH;
            outCanvas.width = outW;
            // 출력 이미지의 메모리 할당
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);

            // 임시 입력 배열 (입력 배열 +2)
            var tmpInImage = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInImage[i] = new Array(inW + 2);

            // 임시 입력 배열 초기화 (127)

            for (var i = 0; i < inH + 2; i++)
                for (var k = 0; k < inW + 2; k++)
                    tmpInImage[i][k] = String.fromCharCode(127);

            // 입력 배열 --> 임시 입력 배열

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    tmpInImage[i + 1][k + 1] = inImage[i][k].charCodeAt(0);
                }
            }

            // 임시 출력 배열

            var tmpOutImage = new Array(inH + 2);
            for (var i = 0; i < outH; i++)
                tmpOutImage[i] = new Array(outW);



            //영상처리 알고리즘 ******* --> 회선 연산 
            var mask = new Array(4);
            var S=0.0;
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    S = 0.0;
                    mask[0] = Math.abs(tmpInImage[i][k] - tmpInImage[i+2][k+2]);
                    mask[1] = Math.abs(tmpInImage[i][k+2] - tmpInImage[i+2][k]);
                    mask[2] = Math.abs(tmpInImage[i][k+1] - tmpInImage[i+2][k+1]);
                    mask[3] = Math.abs(tmpInImage[i+1][k+2] - tmpInImage[i+1][k]);
                    

                    for(var m=0;m<4;m++){
                        if(mask[m] >= S){
                            S = mask[m];
                        }
                    }
                    // console.log(S)
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function blurrOperator(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mSize = parseInt(prompt("숫자를 입력 : ","5"));
            var mask = new Array(mSize);
            for(var i=0;i<mSize; i++){
                mask[i] =new Array(mSize);
            }
            for(var i=0; i<mSize; i++){
                for(var k=0;k<mSize; k++){
                    mask[i][k] = 1.0 / (mSize * mSize);
                }
            }
            //임시 입력 배열(입력 배열 +(mSize - 1))
            var hSize = mSize - 1; //임시 입력 배열 크기
            var tmpInImage = new Array(inH+hSize); //위,아래
            for(var i=0;i<inH+hSize;i++){
                tmpInImage[i] = new Array(inW + hSize);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            var maskArr = new Array(4);
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    mask[0] = Math.abs(tmpInImage[i][k] - tmpInImage[i+2][k+2]);
                    mask[1] = Math.abs(tmpInImage[i][k+2] - tmpInImage[i+2][k]);
                    mask[2] = Math.abs(tmpInImage[i][k+1] - tmpInImage[i+2][k+1]);
                    mask[3] = Math.abs(tmpInImage[i+1][k+2] - tmpInImage[i+1][k]);

                    for(var m=0;m<4;m++){
                        if(mask[m] >= S){
                            S = mask[m];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function diffOpHor(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            var value = prompt("수평 또는 수직을 입력 하시오 : ","수평");
            var mask = 0;
            
            //화소영역처리 (마스크)
            if(value == "수평"){
                mask = [ [ 0, -1, 0],
                [ 0, 1, 0],
                [ 0, 0, 0] ];
            }else if(value == "수직"){
                mask = [ [ 0, 0, 0],
                [ -1, 1, 0],
                [ 0, 0, 0] ];
            }else{
                alert("잘못 입력하셨습니다.");
            }
            // console.log(mask);
            
            
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    tmpOutImage[i][k] += 127;
                }
            }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function sharpening(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [ [ 0.0, -1.0, 0.0],
                        [ -1.0, 5.0, -1.0],
                        [ 0.0, -1.0, 0.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function gaussianFilter(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [ [ 1.0/16.0, 1.0/8.0, 1.0/16.0],
                        [ 1.0/8.0, 1.0/4.0, 1.0/8.0],
                        [ 1.0/16.0, 1.0/8.0, 1.0/16.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function hpfSharp(){
             //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
             outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [ [ -1.0/9.0, -1.0/9.0, -1.0/9.0],
                        [ -1.0/9.0, 8/9.0, -1.0/9.0],
                        [ -1.0/9.0, -1.0/9.0, -1.0/9.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    tmpOutImage[i][k] += 127;
                }
            }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function lpfSharp(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }
            var alpha = parseInt(prompt("투명도(숫자) 입력 : ","10"));

            //화소영역처리 (마스크)
            var mask = [ [ 1.0/9.0, 1.0/9.0, 1.0/9.0],
                        [ 1.0/9.0, 1.0/9.0, 1.0/9.0],
                        [ 1.0/9.0, 1.0/9.0, 1.0/9.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+2); //위,아래
            for(var i=0;i<inH+2;i++){
                tmpInImage[i] = new Array(inW + 2);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+2; i++){
                for(var k=0; k<inW+2;k++){
                    tmpInImage[i][k] = 127;
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = (alpha * inImage[i][k].charCodeAt(0)) - tmpInImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<3;m++){
                        for(var n=0;n<3;n++){
                            S += tmpInImage[i+m][k+n] * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    tmpOutImage[i][k] += 127;
                }
            }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function loGImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [ [ 0.0, 0.0, -1.0, 0.0, 0.0],
                        [  0.0, -1.0, -2.0, -1.0, 0.0],
                        [ -1.0, -2.0, 16.0, -2.0, -1.0],
                        [  0.0, -1.0, -2.0, -1.0, 0.0],
                        [ 0.0, 0.0, -1.0, 0.0, 0.0] ];
            //임시 입력 배열
            var tmpInImage = new Array(inH+4); //위,아래
            for(var i=0;i<inH+4;i++){
                tmpInImage[i] = new Array(inW + 4);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+4; i++){
                for(var k=0; k<inW+4;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<5;m++){
                        for(var n=0;n<5;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function doGImage(){
            //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            //화소영역처리 (마스크)
            var mask = [[0 , 0 , 0 , -1 , -1 , -1 , 0 , 0 , 0 , ] , 
                        [0 , -2 , -3 , -3 , -3 , -3 , -3 , -2 , 0 , ] , 
                        [0 , -3 , -2 , -1 , -1 , -1 , -2 , -3 , 0 , ] , 
                        [-1 , -3 , -1 , 9 , 9 , 9 , -1 , -3 , -1 , ] , 
                        [-1 , -3 , -1 , 9 , 19 , 9 , -1 , -3 , -1 , ] , 
                        [-1 , -3 , -1 , 9 , 9 , 9 , -1 , -3 , -1 , ] , 
                        [0 , -3 , -2 , -1 , -1 , -1 , -2 , -3 , 0 , ] , 
                        [0 , -2 , -3 , -3 , -3 , -3 , -3 , -2 , 0 , ] , 
                        [0 , 0 , 0 , -1 , -1 , -1 , 0 , 0 , 0 , ]];
            //임시 입력 배열
            var tmpInImage = new Array(inH+8); //위,아래
            for(var i=0;i<inH+8;i++){
                tmpInImage[i] = new Array(inW + 8);
            }
            //임시 입력 배열 초기화 (127)
            for(var i=0;i<inH+8; i++){
                for(var k=0; k<inW+8;k++){
                    tmpInImage[i][k] = String.fromCharCode(127);
                }
            }
            //입력 배열 --> 임시 입력 배열 
            for(var i=0;i<inH;i++){
                for(var k=0;k<inW;k++){
                    tmpInImage[i+1][k+1] = inImage[i][k];
                }
            }
            //임시 출력 배열
            var tmpOutImage = new Array(outH);
            for(var i=0; i<outH; i++){
                tmpOutImage[i] = new Array(outW);
            }


            //영상처리 알고리즘 ******* --> 회선 연산 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var S = 0.0;
                    for(var m=0;m<9;m++){
                        for(var n=0;n<9;n++){
                            S += tmpInImage[i+m][k+n].charCodeAt(0) * mask[m][n];
                        }
                    }
                    tmpOutImage[i][k] = S;
                }
            }
            //후처리 작업 (마스크 합계가 0이면 127 정도를 더하기)
            // for(var i=0; i<inH;i++){
            //     for(var k=0; k<inW; k++){
            //         tmpOutImage[i][k] += 127;
            //     }
            // }

            //임시 출력 배열 --> 출력 배열 
            for(var i=0; i<inH;i++){
                for(var k=0; k<inW; k++){
                    var v = tmpOutImage[i][k];
                    if(v > 255.0)
                        v=255.0;
                    if(v<0.0)
                        v=0.0;
                    outImage[i][k] = String.fromCharCode(parseInt(v));
                }
            }

            // ** 입력 메모리의 내용을 화면에 출력하기 . 
            displayImage();
        }

        function rotateNine(){
             //중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존
            outH = inH;
            outW = inW;
            // 캔버스 크기를 결정 
            outCanvas.height = outH;
            outCanvas.width = outW;
            //입력 이미지의 메모리 할당 
            outImage; //2차원 배열 (이미지 --> 2차원 배열)
            outImage = new Array(outH);
            for(var i=0; i<outH; i++){
                outImage[i] = new Array(outW);
            }

            imageNine = new Array(inH);
            for(var i=0;i<inH;i++){
                imageNine[i] = new Array(inW);
            }

            for(var i=0; i<inH; i++){
                for(var k=0;k<inW;k++){
                    imageNine[k][(inH - i - 1)] = inImage[i][k];
                }
            }

            for(var i=0;i<inH; i++){
                for(var k=0;k<inW;k++){
                    outImage[i][k] = imageNine[i][k];
                }
            }
            displayImage();
        }

        function rotateNum(){
             
            
            var centerH,centerW,newH,newW;
            var radian, value;

            var degree  = parseInt(prompt("회전 각도 : ", "45"));
            radian = degree * Math.PI / 180.0;//cos,sin 값 안에 들어가는 각도 값이 라디안 값 => 라디안으로 변경

            outH = Math.floor((inW) * Math.abs(Math.sin(radian)) + (inH) * Math.abs(Math.cos(radian)));
            outW = Math.floor((inW) * Math.abs(Math.cos(radian)) + (inH) * Math.abs(Math.sin(radian)));

            outCanvas.height = outH;
            outCanvas.width = outW;

            //회전 후 사진의 중앙점 까지의 길이 
            centerH = outH/2;
            centerW = outW/2;

            //출력 이미지의 메모리 할당
            outImage = new Array(outH);
            for(var i=0;i<outH;i++){
                outImage[i] = new Array(outW);
            }
            //출력 이미지를 초기화 시키기 
            for(var i=0; i<outH; i++){
                for(var k=0; k<outH; k++){
                    outImage[i][k] = String.fromCharCode(0);
                }
            }
            for(var i=0; i<outH; i++){
                for(var k=0;k<outW;k++){
                    newW = parseInt((i-centerW) * Math.cos(radian)-(k-centerH)*Math.sin(radian)+inW/2);
                    newH = parseInt((i-centerW) * Math.sin(radian)+(k-centerH)*Math.cos(radian)+inW/2);

                    if(newH < 0 || newH >= inH){
                        value = 0;
                    }else if (newW < 0 || newW >= inW) {
                        value = 0;
                    }else{
                        value = inImage[newW][newH].charCodeAt(0);
                    }
                    outImage[i][k] = value;
                }
            }
            // ** 출력 메모리의 내용을 화면에 출력하기 . 
                
            outPaper = outCtx.createImageData(outH,outW); //캔버스에 종이 붙이기 (크기는 캔버스 동일)
            for(var i=0; i<outH; i++){
                for(var k=0; k<outW; k++){
                    var pix = outImage[i][k]; // 이상한 문자(꽯)를 숫자(231)로.
                    //RGB값이 다르면 color고 , RGB값이 같으면 Gray Scale 임 
                    outPaper.data[(i*outH + k) * 4 + 0] = pix; //RED,4바이트로 한개의 컬러를 표현  
                    outPaper.data[(i*outH + k) * 4 + 1] = pix; //GREEN,종이의 한 점당 4바이트  
                    outPaper.data[(i*outH + k) * 4 + 2] = pix;  //Blue 
                    outPaper.data[(i*outH + k) * 4 + 3] = 255;  //Alpha

                }
            }
            outCtx.putImageData(outPaper,0,0); //(0,0) 좌표에 붙여라 . 
        }

        

    </script>
</head>
<body onload="init()">
    <form>
        <input type="file" id="inFile" onchange="loadImage()"/> <br>
        <label> 그레이 영상처리 Beta 7 </label>
        <select name="imageAlgo" onchange="selectAlgorithm(this.form.imageAlgo)">
            <option value=0>선택하세요</option>
            <optgroup label="화소점 처리">
                <option value = 101> 동일 영상 처리 </option>
                <option value = 102> 영상 밝게/어둡게 </option>
                <!-- <option value = 102> 영상 밝게/어둡게 (연속) </option> -->
                <option value = 103> 흑백(127기준) </option>
                <option value = 104> 흑백(입력값 기준) </option>
                <option value = 105> 흑백(평균값 기준) </option>
                <option value = 106> 흑백(중앙값 기준) </option>
                <option value = 107> 파라볼라(cap) </option>
                <option value = 108> 감마 보정 프로그램 </option>
            </optgroup>
            <optgroup label="기하학 처리">
                <option value=201>축소하기</option>
                <option value=202>확대하기</option>
                <option value=203>확대하기(백워딩)</option>
                <option value=204>양선형 보간법</option>
            </optgroup>
            <optgroup label="히스토그램">
                <option value=301> 히스토그램 스트레칭 </option>
                <option value=302> 엔드인 탐색 </option>
                <option value=303> 평활화 </option>
            </optgroup>
            <optgroup label="기하학 처리2">
                <option value=401> 반전하기 </option>
                <option value=402> 미러링하기 </option>
                <option value=403> 90도 회전하기 </option>
                <option value=404> 회전하기(각도입력) </option>
            </optgroup>
            <optgroup label="화소처리2">
                <option value=501> 화소처리(AND 프로그램) </option>
                <option value=502> 화소처리(OR 프로그램) </option>
                <option value=303> 화소처리(XOR 프로그램) </option>
                <option value=504> 투명도 주기 (Alpha) </option>
                <option value=505> 범위 강조 변환 </option>
            </optgroup>
            <optgroup label="화소 영역처리">
                <option value=601> 엠보싱 </option>
                <option value=602> 블러링(원본) </option>
                <option value=603> 경계선1 </option>
                <option value=604> 유사 연산자 </option>
                <option value=605> 차 연산자 </option>
                <option value=606> LoG </option>
                <option value=607> DoG </option>
                <option value=608> 블러링(진하기) </option>
                <option value=609> 이동과 차분 처리 </option>
                <option value=610> 샤프닝 </option>
                <option value=611> 가우시안 필터 </option>
                <option value=612> 고주파 필터 샤프닝 </option>
                <option value=613> 저주파 필터 샤프닝 </option>
            </optgroup>
        </select>
        <hr>
        <canvas id="inCanvas" style="background-color:rgb(96, 202, 202)"></canvas>
        <canvas id="outCanvas" style="background-color:rgb(220, 231, 210)"></canvas>

    </form>
</body>
</html>


 




